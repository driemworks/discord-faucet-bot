var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// /**
//  * Encryption to the Future
//  * This class initializes the ETF.js SDK
//  */
// see: https://polkadot.js.org/docs/api/FAQ/#since-upgrading-to-the-7x-series-typescript-augmentation-is-missing
import '@polkadot/api-augment';
import { ApiPromise, WsProvider } from '@polkadot/api';
import { Metadata, TypeRegistry } from '@polkadot/types';
import { hexToU8a } from '@polkadot/util';
import { ScProvider } from '@polkadot/rpc-provider';
import * as Sc from '@ideallabs/connect';
import init, { EtfApiWrapper } from '@ideallabs/etf-sdk';
import { EventEmitter } from 'events';
/**
 * Encryption to the Future
 * This class initializes the ETF.js SDK
 * It assumes a time-based SlotScheduler
 */
export class Etf {
    /**
     * Constructor for the etf api
     * @param providerMultiAddr (optional): The multiaddress of an RPC node
     * e.g. insecure local node:    ws://localhost:9944
     *      secure websocket (rpc): wss://etf1.idealabs.network:443
     */
    constructor(providerMultiAddr) {
        this.providerMultiAddr = providerMultiAddr;
        this.eventEmitter = new EventEmitter();
    }
    /**
     * Connect to the chain and start etf api wrapper
     * @param chainSpec The ETF Network (raw) chain spec
     */
    init(chainSpec, extraTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            let provider;
            if (this.providerMultiAddr == undefined) {
                let spec = JSON.stringify(chainSpec);
                provider = new ScProvider(Sc, spec);
                yield provider.connect();
            }
            else {
                provider = new WsProvider(this.providerMultiAddr);
            }
            this.api = yield ApiPromise.create({
                provider,
                types: Object.assign({}, extraTypes)
            });
            yield this.api.isReady;
            console.log('api is ready');
            this.registry = new TypeRegistry();
            // load metadata and predigest
            const data = yield this.api.rpc.state.getMetadata();
            this.registry.register({
                PreDigest: {
                    slot: 'u64',
                    secret: '[u8;48]',
                    proof: '[u8;224]',
                },
            });
            const metadata = new Metadata(this.registry, data.toHex());
            this.registry.setMetadata(metadata);
            this.listenForSecrets(this.eventEmitter);
            yield init();
            console.log('wasm initialized successfully');
            const pps = yield this.api.query.etf.ibeParams();
            this.ibePubkey = pps[1];
            this.etfApi = new EtfApiWrapper(pps[1], pps[2]);
            console.log('etf api initialized');
            const version = String.fromCharCode(...this.etfApi.version());
            console.log('version ' + version);
        });
    }
    /**
     * A proxy to the polkadotjs api type registry creation
     */
    createType(typeName, typeData) {
        return this.api.registry.createType(typeName, typeData);
    }
    /**
     * Attempt to fetch secrets from each slot, if it
     * @param slots the slots
     */
    secrets(slots) {
        return __awaiter(this, void 0, void 0, function* () {
            let sks = [];
            let latest = this.getLatestSlot();
            for (const slotId of slots) {
                // division by 2 since slot numbers increment by 2 but block numbers increment by 1
                let distance = (latest - slotId) / 2;
                let blockNumber = this.latestBlockNumber - distance;
                let blockHash = yield this.api.query.system.blockHash(blockNumber);
                let blockHeader = yield this.api.rpc.chain.getHeader(blockHash);
                let encodedPreDigest = blockHeader.digest.logs[0].toHuman()['PreRuntime'][1];
                const predigest = this.registry.createType('PreDigest', encodedPreDigest);
                let sk = hexToU8a(predigest.toJSON()['secret'].toString());
                sks.push(sk);
            }
            return sks;
        });
    }
    /**
     * Encrypt a message
     * @param message The message to encrypt
     * @param n The number of slots to encrypt for
     * @param schedulerInput The schedulerInput for the slot scheduler
     * @returns the ciphertext and slot schedule
     */
    encrypt(message, threshold, slotSchedule, seed) {
        if (slotSchedule === undefined || slotSchedule === null) {
            return { ct: "" };
        }
        let t = new TextEncoder();
        let ids = [];
        for (const id of slotSchedule) {
            ids.push(t.encode(id.toString()));
        }
        return {
            ct: this.etfApi.encrypt(t.encode(message), ids, threshold, t.encode(seed)),
        };
    }
    /**
     * Decrypt the ciphertext
     * @param ct
     * @param nonce
     * @param capsule
     * @param slotSchedule
     * @returns
     */
    decrypt(ct, nonce, capsule, slotIds) {
        return __awaiter(this, void 0, void 0, function* () {
            let sks = yield this.secrets(slotIds);
            return this.etfApi.decrypt(ct, nonce, capsule, sks);
        });
    }
    // listen for incoming block headers and emit an event
    // when new headers are encountered
    // currently stores no history
    listenForSecrets(eventEmitter) {
        this.api.rpc.chain.subscribeNewHeads((header) => {
            // read the predigest from each block
            const encodedPreDigest = header.digest.logs[0].toHuman()['PreRuntime'][1];
            const predigest = this.registry.createType('PreDigest', encodedPreDigest);
            let latest = predigest.toHuman();
            this.latestSlot = latest;
            this.latestBlockNumber = header['number'].toNumber();
            eventEmitter.emit('blockHeader', latest);
        });
    }
    getLatestSlot() {
        return Number.parseInt(this.latestSlot.slot.replaceAll(',', ''));
    }
}
