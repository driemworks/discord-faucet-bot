/// <reference types="node" />
import '@polkadot/api-augment';
import { EventEmitter } from 'events';
/**
 * Encryption to the Future
 * This class initializes the ETF.js SDK
 * It assumes a time-based SlotScheduler
 */
export declare class Etf<T extends {}> {
    latestSlot: any;
    latestBlockNumber: number;
    ibePubkey: number;
    private providerMultiAddr;
    private api;
    private registry;
    private etfApi;
    eventEmitter: EventEmitter;
    /**
     * Constructor for the etf api
     * @param providerMultiAddr (optional): The multiaddress of an RPC node
     * e.g. insecure local node:    ws://localhost:9944
     *      secure websocket (rpc): wss://etf1.idealabs.network:443
     */
    constructor(providerMultiAddr?: string);
    /**
     * Connect to the chain and start etf api wrapper
     * @param chainSpec The ETF Network (raw) chain spec
     */
    init(chainSpec: string, extraTypes?: any): Promise<void>;
    /**
     * A proxy to the polkadotjs api type registry creation
     */
    createType(typeName: string, typeData: any): any;
    /**
     * Attempt to fetch secrets from each slot, if it
     * @param slots the slots
     */
    secrets(slots: number[]): Promise<any[]>;
    /**
     * Encrypt a message
     * @param message The message to encrypt
     * @param n The number of slots to encrypt for
     * @param schedulerInput The schedulerInput for the slot scheduler
     * @returns the ciphertext and slot schedule
     */
    encrypt(message: string, threshold: number, slotSchedule: number[], seed: string): {
        ct: any;
    };
    /**
     * Decrypt the ciphertext
     * @param ct
     * @param nonce
     * @param capsule
     * @param slotSchedule
     * @returns
     */
    decrypt(ct: Uint8Array, nonce: Uint8Array, capsule: Uint8Array, slotIds: number[]): Promise<any>;
    listenForSecrets(eventEmitter: EventEmitter): void;
    getLatestSlot(): number;
}
