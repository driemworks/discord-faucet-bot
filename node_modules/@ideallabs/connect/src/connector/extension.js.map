{"version":3,"file":"extension.js","sourceRoot":"","sources":["extension.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ToApplication,\n  ToExtension,\n} from \"@substrate/connect-extension-protocol\"\nimport {\n  AlreadyDestroyedError,\n  CrashError,\n  JsonRpcDisabledError,\n  Chain,\n  JsonRpcCallback,\n  ScClient,\n} from \"./types.js\"\nimport { WellKnownChain } from \"../WellKnownChain.js\"\nimport { getSpec } from \"./specs/index.js\"\n\nconst listeners = new Map<string, (msg: ToApplication) => void>()\nif (typeof window === \"object\") {\n  window.addEventListener(\n    \"message\",\n    ({ data }: MessageEvent<ToApplication>) => {\n      if (data?.origin !== \"substrate-connect-extension\") return\n      listeners.get(data.chainId)?.(data)\n    },\n  )\n}\n\nfunction getRandomChainId(): string {\n  const arr = new BigUint64Array(2)\n  // It can only be used from the browser, so this is fine.\n  crypto.getRandomValues(arr)\n  const result = (arr[1] << BigInt(64)) | arr[0]\n  return result.toString(36)\n}\n\n/**\n * Returns a {@link ScClient} that connects to chains by asking the substrate-connect extension\n * to do so.\n *\n * This function assumes that the extension is installed and available. It is out of scope of this\n * function to detect whether this is the case.\n * If you try to add a chain without the extension installed, nothing will happen and the\n * `Promise`s will never resolve.\n */\nexport const createScClient = (): ScClient => {\n  const chains = new Map<Chain, string>()\n\n  const internalAddChain = async (\n    isWellKnown: boolean,\n    chainSpecOrWellKnownName: string,\n    jsonRpcCallback?: JsonRpcCallback,\n    potentialRelayChainIds = [] as string[],\n  ): Promise<Chain> => {\n    type ChainState =\n      | {\n          state: \"pending\"\n          waitFinished: () => void\n        }\n      | {\n          state: \"ok\"\n        }\n      | { state: \"dead\"; error: AlreadyDestroyedError | CrashError }\n\n    let resolve: undefined | (() => void)\n    const initFinished = new Promise((res) => {\n      resolve = () => res(null)\n    })\n    const chainState: { id: string; state: ChainState } = {\n      id: getRandomChainId(),\n      state: {\n        state: \"pending\",\n        waitFinished: resolve!,\n      },\n    }\n\n    if (listeners.has(chainState.id))\n      throw new Error(\n        \"Unexpectedly randomly generated the same chain ID twice despite 64bits of entropy\",\n      )\n\n    // Setup the listener for this chain.\n    // This listener should never be removed until we are no longer interested in this chain.\n    // Removing then re-adding the listener could cause messages to be missed.\n    listeners.set(chainState.id, (msg) => {\n      switch (chainState.state.state) {\n        case \"pending\": {\n          const waitFinished = chainState.state.waitFinished\n          switch (msg.type) {\n            case \"chain-ready\": {\n              chainState.state = {\n                state: \"ok\",\n              }\n              break\n            }\n            case \"error\": {\n              chainState.state = {\n                state: \"dead\",\n                error: new CrashError(\n                  \"Error while creating the chain: \" + msg.errorMessage,\n                ),\n              }\n              break\n            }\n            default: {\n              // Unexpected message. We ignore it.\n              // While it could be tempting to switch the chain to `dead`, the extension might\n              // think that the chain is still alive, and the state mismatch could have\n              // unpredictable and confusing consequences.\n              console.warn(\n                \"Unexpected message of type `msg.type` received from substrate-connect extension\",\n              )\n            }\n          }\n          waitFinished()\n          break\n        }\n        case \"ok\": {\n          switch (msg.type) {\n            case \"error\": {\n              chainState.state = {\n                state: \"dead\",\n                error: new CrashError(\n                  \"Extension has killed the chain: \" + msg.errorMessage,\n                ),\n              }\n              break\n            }\n            case \"rpc\": {\n              if (jsonRpcCallback) {\n                jsonRpcCallback(msg.jsonRpcMessage)\n              } else {\n                console.warn(\n                  \"Unexpected message of type `msg.type` received from substrate-connect extension\",\n                )\n              }\n              break\n            }\n            default: {\n              // Unexpected message. We ignore it.\n              // While it could be tempting to switch the chain to `dead`, the extension might\n              // think that the chain is still alive, and the state mismatch could have\n              // unpredictable and confusing consequences.\n              console.warn(\n                \"Unexpected message of type `msg.type` received from substrate-connect extension\",\n              )\n            }\n          }\n          break\n        }\n        case \"dead\": {\n          // We don't expect any message anymore.\n          break\n        }\n      }\n    })\n\n    // Now that everything is ready to receive messages back from the extension, send the\n    // add-chain message.\n    if (isWellKnown) {\n      postToExtension({\n        origin: \"substrate-connect-client\",\n        chainId: chainState.id,\n        type: \"add-well-known-chain\",\n        chainName: chainSpecOrWellKnownName,\n      })\n    } else {\n      postToExtension({\n        origin: \"substrate-connect-client\",\n        chainId: chainState.id,\n        type: \"add-chain\",\n        chainSpec: chainSpecOrWellKnownName,\n        potentialRelayChainIds,\n      })\n    }\n\n    // Wait for the extension to send back either a confirmation or an error.\n    // Note that `initFinished` becomes ready when `chainState` has been modified. The outcome\n    // can be known by looking into `chainState`.\n    await initFinished\n\n    // In the situation where we tried to create a well-known chain, the extension isn't supposed\n    // to ever return an error. There is however one situation where errors can happen: if the\n    // extension doesn't recognize the desired well-known chain because it uses a different list\n    // of well-known chains than this code. To handle this, we download the chain spec of the\n    // desired well-known chain and try again but this time as a non-well-known chain.\n    if (isWellKnown && chainState.state.state === \"dead\") {\n      // Note that we keep the same id for the chain for convenience.\n      let resolve: undefined | (() => void)\n      const initFinished = new Promise((res) => {\n        resolve = () => res(null)\n      })\n      chainState.state = {\n        state: \"pending\",\n        waitFinished: resolve!,\n      }\n\n      postToExtension({\n        origin: \"substrate-connect-client\",\n        chainId: chainState.id,\n        type: \"add-chain\",\n        chainSpec: getSpec(chainSpecOrWellKnownName),\n        potentialRelayChainIds: [],\n      })\n\n      await initFinished\n    }\n\n    // Now check the `chainState` to know if things have succeeded.\n    if (chainState.state.state === \"dead\") {\n      throw chainState.state.error\n    }\n\n    // Everything is successful.\n    const chain: Chain = {\n      sendJsonRpc: (jsonRpcMessage) => {\n        if (chainState.state.state === \"dead\") {\n          throw chainState.state.error\n        }\n\n        if (!jsonRpcCallback) throw new JsonRpcDisabledError()\n        postToExtension({\n          origin: \"substrate-connect-client\",\n          chainId: chainState.id,\n          type: \"rpc\",\n          jsonRpcMessage,\n        })\n      },\n      remove: () => {\n        if (chainState.state.state === \"dead\") {\n          throw chainState.state.error\n        }\n\n        chainState.state = {\n          state: \"dead\",\n          error: new AlreadyDestroyedError(),\n        }\n\n        listeners.delete(chainState.id)\n        chains.delete(chain)\n\n        postToExtension({\n          origin: \"substrate-connect-client\",\n          chainId: chainState.id,\n          type: \"remove-chain\",\n        })\n      },\n    }\n\n    // This mapping of chains is kept just for the `potentialRelayChainIds` field.\n    chains.set(chain, chainState.id)\n\n    return chain\n  }\n\n  return {\n    addChain: (chainSpec: string, jsonRpcCallback?: JsonRpcCallback) =>\n      internalAddChain(false, chainSpec, jsonRpcCallback, [...chains.values()]),\n    addWellKnownChain: (\n      name: WellKnownChain,\n      jsonRpcCallback?: JsonRpcCallback,\n    ) => internalAddChain(true, name, jsonRpcCallback),\n  }\n}\n\n// Sends a message to the extension. This function primarly exists in order to provide strong\n// typing for the message.\nfunction postToExtension(msg: ToExtension) {\n  window.postMessage(msg, \"*\")\n}\n"]}